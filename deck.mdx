import { Appear, Notes, Split, Image } from "mdx-deck";
import {
  CodeSurfer,
  Step,
} from "code-surfer";

import { github, vsDark } from "@code-surfer/themes";

export const theme = vsDark;

# Intro

### Alec Brunelle

### Software dev @ Yolk AI

<Notes>

* i.t. automation, e.g. chatbot, intranet

</Notes>

---

Frontend developer for three years

Apollo Local State for a year

<Notes>

- yolk ai all apps using it
- been amazing
- really love it
- passionate about it
- very excited and feel lucky to work on it everyday

</Notes>

---

<Image src="https://ludiq.io/assets/images/Flow-New.png" width="75%" height="75%" />

<Notes>

- I am sure all you front end developers have seen this before
- complex single page apps which have a combination of remote data and local data are a great candidate for ALS
    - e.g. a flow editor (it was ours in that case), a multi-page form,
    - graphql api Data
    - which nodes the user has edited, local data
- difficult problem but many many solutions
  - e.g. redux, react state/context, flux
  - apollo local state is one of those solutions
- today I am going to tell you my experience with apollo local state

- TODO: maybe talk about react state
- can use React State for a lot of interactions
- doesnt scale well, starts to break down when multiple components need to hold state
  * they need to know about each other

* using ALS for a flow editor sort of like this
  * invested heavily in it

</Notes>

---

Apollo Client

* Query and Mutate Remote Data
* A Cache with different fetch policies

<Notes>

- you are likely already usig graphql and also using apollo client if you are building a frontend
- apollo client lets you query and mutate remote data on a graphql api
- has a built-in cache which has enables some pretty awesome features
  * e.g. blah blah blah
* this is how apollo client gives you a lot of nice features like different fetch policies

</Notes>

---

Network Cache

<Notes>

* do a request, its in the cache
* one part of the cache is updated,
* all components which are querying that part of the cache will be updated

</Notes>

---

Network Cache === Local State Cache

<Notes>

* this is where apollo local state comes in
* instead of bringing in another state management library like Redux so the Apollo cache can be a single source of truth.
* meaning your network cache is the same exact thing as your local state cache

</Notes>

---

My Pros & My Cons

<Notes>

* lets go into apollo local states pros and cons
* these are the big ones from my experience
* are some more on both sides that i dont mention
* my talk so I get to talk about what I want

</Notes>

---

# Pro

It's GraphQL

<Notes>

pro:

* Actions and data manipulations upon the local state cache are performed with mutations,
something that previous GraphQL users already understand

</Notes>

---

# Pro

It's Apollo Client

<Notes>

- almost zero extra config if already using apollo client
- very similar to how you query/mutate remote data
- Staying within the Apollo ecosystem meant smooth integration with existing tools, meaning less overhead for developers.
- same api to query and mutate data
- apollo dev tools

</Notes>

---

# Con

Boilerplate / Dev Experience

<Notes>

- could be much better
- part of the reason why I am giving this talk
- want it to get better as I had such a good experience
- when comparing the dev tools to something like redux, its less feature heavy

</Notes>

---

<Image src="./images/issuenameinput.png">

Example

</Image>

<Notes>

* here is a simple example of editing a github issue name
* some remote data that is already in the cache
* didnt use too much for client only data

</Notes>

---

<CodeSurfer>

```graphql title="Define client-side schema" subtitle="clientOnly.graphql"
extend type Mutation {
  # A mutation which edits the name on a Github Issue.
  editGithubIssue(input: EditGithubIssueInput!): Boolean
}

input EditGithubIssueInput {
  id: ID!
  name: String!
}
```

```jsx 2,7:14 title="Use the mutation" subtitle="IssueInput.tsx"

const IssueInput: React.FC<{ issue: GithubIssuePiece }> = ({ issue }) => {
  const updateIssuename = useMutation(UPDATE_ISSUE_NAME);
  return (
    <input
      value={issue.name}
      onChange={newInputValue => {
        updateIssuename({
          variables: {
            input: {
              id: issue.id,
              name: newInputValue
            }
          }
        });
      }}
    />
    <button>Save</button>
    <button>Cancel</button>
  );
};

```

</CodeSurfer>

<Notes>

* define the mutation schema
* this looks similar to a graphql api schema

* use enters new value in the input
* client side mutation is run
* updates the cache
* which makes the queries on issue name run again
* thus updating all parts of your app where issue name is
* TODO: insert diagram

</Notes>

---


<CodeSurfer>

```ts file=./mutations/updateIssueName.ts title="the mutation resolver" subtitle="It's pretty big"
```

```diff 11:15 subtitle="Define local mutation"
```

```diff 17:24 subtitle="Define fragment"
```

```diff 44:48 subtitle="Get the data from the cache"
```

```diff 54:57 subtitle="Update the data"
```

```diff 60:65 subtitle="Write the data to the cache"
```

</CodeSurfer>

<Notes>

* Goes to show the dev experience here is lacking
* this is how to do it, straight from the docs
* Ts makes this worse but I havent wrote regular JS in almost two years

</Notes>

---

<Image src="https://media.giphy.com/media/11tKP5jvSJdLXi/giphy.gif" height="50%" width="50%" />

<Notes>

* This was not as bad in redux
* Not much boilerplate
* Was easy to test
* in redux, you defined an action and wrote the resolver which:
  * was usually small 
  * easily testable

</Notes>

---

Problems

* Liberal
* Boilerplate
* Testing

<Notes>

* way too much code which could go wrong or devs forgetting to do things
* lots of boilerplate and testing was not easy, very terse and prone to error
  * way too much code for such small manipulations to data
* to test this you need a fake store and perform fake mutation on it
* hard to test
  * lots of use of external apis

</Notes>

---

Solution after many mutations written...

<Notes>

* what we came up with which made the whole process a lot more simple

</Notes>

---


After some thinking...

<Notes>

* there are some patterns here which are starting to appear

</Notes>

---

<Split>

<CodeSurfer>

```ts file=./mutations/updateIssueName.ts 43:48,59:65
```

</CodeSurfer>

Redux gave you back the entire cache

<Notes>

</Notes>

</Split>

---

<Split>

<CodeSurfer>

```ts file=./mutations/updateIssueName.ts 53:57
```

</CodeSurfer>

Pure reducer function

</Split>

---

<CodeSurfer>

```ts file=./common/createResolver.ts title="The generator"
```

```diff 10:26
```

```diff 42:46 subtitle="Get the data from the cache"
```

```diff 53 subtitle="Update the data"
```

```diff 56:61 subtitle="Write the data to the cache"
```

</CodeSurfer>

---

<CodeSurfer>

```ts title="Lets go back to our issue mutation" file=./mutations/newUpdateIssueName.ts
```

```diff 10:17 subtitle="still have the fragment"
```

```diff 19:25 subtitle="the new reducer function"
```

```diff 27:34 subtitle="export the right config"
```

</CodeSurfer>

---

With this new set of utility function, it covered about 90% of our use cases.

<Notes>

* assumption you are writing data in the same format you read it
* way less chance for mess ups
* which was almost always the case
* more complex mutations that need data from elsewhere can opt-out
* became an even better experience
* very easy to test these reducers

</Notes>

---

recap

* chose to invest heavily in apollo local state for a complicated flow editor - type app
* saw problems in apollo local state which required tweaking
* used inspiration from redux to make apollo local state experience much better

---

[Looking to improve it.](https://spectrum.chat/apollo/apollo-link-state/apollo-link-state-vs-redux-vs-react-hooks-context~dcb1118c-8819-4593-8b22-040229ed4282?m=MTU1MTM3ODkzNjcxNg==)

---

# If you liked this:

## https://blog.alec.coffee/apollo-local-state-pains/

---

# Follow Me:

## [@yourboybigal](https://twitter.com/yourboybigal)

## [alec@alec.coffee](mailto:alec@alec.coffee)
