import { Appear, Notes, Split, Image } from "mdx-deck";
import {
  CodeSurfer,
  Step,
} from "code-surfer";

import { github, nightOwl } from "@code-surfer/themes";

export const theme = nightOwl;

### Alec Brunelle

### Software dev @ Yolk AI

#### Frontend ~ 3 years

#### Apollo Local State ~ 1 year

<Notes>

* i.t. automation, e.g. chatbot, intranet

</Notes>

---

## What this talk is

* What/Why Apollo Local State ü§î
* My experience üòÉ
* My Pros and Cons ‚öîÔ∏è
* A solution for the Cons ‚òÄÔ∏è

---

<Image src="https://res.cloudinary.com/dscgr6mcw/image/upload/v1574739802/apollo-state-talk/Flow-New.png" width="75%" height="75%" />

<Notes>

- implemting a ui like this is tough, this is where apollo link state usually comes in
- complex single page apps which have a combination of remote data and local data are a great candidate for ALS
    - e.g. a flow editor (it was ours in that case), a multi-page form,
    - graphql api Data
    - which nodes the user has edited, local data
- difficult problem but many many solutions
  - e.g. redux, react state/context, flux
  - apollo local state is one of those solutions

- TODO: maybe talk about react state
- can use React State for a lot of interactions
- doesnt scale well, starts to break down when multiple components need to hold state
  * they need to know about each other

* using ALS for a flow editor sort of like this
  * invested heavily in it

</Notes>

---

## Apollo Client

* Pre-req to Apollo Local State
* Query and Mutate Remote Data from a GraphQL API
* A Network Cache

<Notes>

- if you are building a frontend you are likely already usig graphql and also using apollo client
- apollo client lets you query and mutate remote data on a graphql api
- has a built-in cache which has enables some pretty awesome features
  * e.g. blah blah blah
* this is how apollo client gives you a lot of nice features like different fetch policies

</Notes>

---

### Network Cache

<Image src="https://res.cloudinary.com/dscgr6mcw/image/upload/v1574273795/apollo-state-talk/1_CbevjJN6IQBk7gbh38V-2g.png" height="70%" width="70%" />

<Notes>

* do a request, its in the cache
* one part of the cache is updated,
* all components which are querying that part of the cache will be updated

</Notes>

---

Network Cache === <strong>Local State Cache</strong>

<Notes>

* this is where apollo local state comes in
* instead of duplicating the cache/store where your client side state will live
  * might as well use the same one amirite
* instead of bringing in another state management library like Redux so the Apollo cache can be a single source of truth.
* meaning your network cache is the same exact thing as your local state cache

</Notes>

---

## My Experience

A-

---

## My Pros & My Cons

<Notes>

* lets go into apollo local states pros and cons
* these are the big ones from my experience
* are some more on both sides that i dont mention
* my talk so I get to talk about what I want

</Notes>

---

# Pro

It's GraphQL

<Notes>

pro:

* data manipulations upon the local state cache are performed with mutations,
something that previous GraphQL users already understand
* fragments
* lingo is the same

</Notes>

---

# Pro

It's Apollo Client

<Notes>

- funded company
- Staying within the Apollo ecosystem meant smooth integration with existing tools, meaning less overhead for developers.
- almost zero extra config if already using apollo client
- very similar to how you query/mutate remote data
- apollo dev tools

</Notes>

---

# Con

Boilerplate

<Notes>

- polluting your codebase
- because one action per reducer, means mutations can have a lot of code

</Notes>

---

Let's do an example üè´

---

E.g. Editing a Github Issue name üñäÔ∏è

<Image src="https://res.cloudinary.com/dscgr6mcw/image/upload/v1574737880/apollo-state-talk/issuenameinput.png" height="25%" width="90%" />

<Notes>

* here is a simple example of editing a github issue name
* some remote data that is already in the cache
* didnt use too much for client only data

</Notes>

---

<CodeSurfer>

```jsx file=./components/IssueInput.tsx title="Example React Component" subtitle="IssueInput.tsx"
```

```diff 12,15:26 subtitle="Use the mutation"
```

```diff 3:7 subtitle="Define the mutation"
```

```diff 5[36:43]
```

</CodeSurfer>

<Notes>

* define the mutation 
* looks similar to remote grapqhl api mutation

* use enters new value in the input
* client side mutation is run
* updates the cache
* which makes the queries on issue name run again
* thus updating all parts of your app where issue name is

</Notes>

---

<CodeSurfer>

```graphql title="Define client-side schema" subtitle="clientOnly.graphql"
extend type Mutation {
  # A mutation which edits the name on a Github Issue.
  editGithubIssue(input: EditGithubIssueInput!): Boolean
}

input EditGithubIssueInput {
  id: ID!
  name: String!
}
```

```diff 1[1:6] title="Apollo Client will merge the schemas"
```

</CodeSurfer>

<Notes>

* very familar to people who have worked with graphql apis
* notice the extend statement on the type from the server type
* apollo client will merge the schemas

</Notes>

---


<CodeSurfer>

```ts file=./mutations/updateIssueName.ts title="next, the resolver"
```

```diff 17:24 subtitle="Define fragment"
```

```diff 42:46 subtitle="Get the data from the cache"
```

```diff 51:54 subtitle="Update the data"
```

```diff 56:61 subtitle="Write the data to the cache"
```

</CodeSurfer>

<Notes>

* next the resolver which handles actually mutating the cache data
* Goes to show the dev experience here is lacking
* this is how to do it, straight from the docs
* Ts makes this worse but I havent wrote regular JS in almost two years

</Notes>

---

<Image src="https://media.giphy.com/media/11tKP5jvSJdLXi/giphy.gif" height="50%" width="50%" />

<Notes>

* just like ellen, i was disgusted
* repeat this for every mutation
* This was not as bad in redux
* Not much boilerplate
* Was easy to test
* in redux, you defined an action and wrote the resolver which:
  * was usually small 
  * easily testable

</Notes>

---

## üî¥ Problems üî¥

* Boilerplate
* Testing

<Notes>

- because one action per reducer, means mutations can have a lot of code
* way too much code which could go wrong or devs forgetting to do things
* to test this you need a fake store and perform fake mutation on it
* hard to test
  * lots of use of external apis

</Notes>

---

After some ü§î and many mutations ‚úçÔ∏è ...

<Notes>

* what we came up with which made the whole process a lot more simple
* we started to see some patterns

</Notes>

---

<Split>

<CodeSurfer>

```ts file=./mutations/updateIssueName.ts 42:46,56:61
```

</CodeSurfer>

The üí∞ of GraphQL

<Notes>

</Notes>

</Split>

---

<Split>

<CodeSurfer>

```ts file=./mutations/updateIssueName.ts 51:54
```

</CodeSurfer>

Isn't this part familar ü§î

</Split>

---

* insert image of hot new-ness

---

<CodeSurfer>

```ts title="Our new mutation resolver" file=./mutations/newUpdateIssueName.ts
```

```diff 10:17 subtitle="Still have the fragment"
```

```diff 19:25 subtitle="Our new reducer function, testable!"
```

```diff 27:34 subtitle="run the generator"
```

</CodeSurfer>

---

<CodeSurfer>

```ts file=./resolvers/createResolver.ts title="The generator"
```

```diff 18:25
```

```diff 42:46,56:61 subtitle="Read/Write data to the cache"
```

```diff 53 subtitle="Update the data"
```

</CodeSurfer>

---

With this new utility function, it covered about 90% of our use cases.

<Notes>

* assumption you are writing data in the same format you read it
* way less chance for mess ups
* more complex mutations that need data from elsewhere can opt-out
* became an even better experience
* very easy to test these reducers

</Notes>

---

Recap üìö

* Learned about Apollo Local State and how it relates to Apollo Client
* Saw problems state which required tweaking
* Used inspiration from redux to make the experience much better

---

# If you liked this:

## üñºÔ∏è https://talk.alec.coffee

## üîó https://blog.alec.coffee/apollo-local-state-pains/

---

# Follow Me:

## üê¶ [@yourboybigal](https://twitter.com/yourboybigal)

## ‚úâÔ∏è [alec@alec.coffee](mailto:alec@alec.coffee)
