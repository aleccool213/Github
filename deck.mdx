import { Appear, Notes, Split } from "mdx-deck";
import {
  CodeSurfer,
  Step
} from "code-surfer";

import { github, vsDark } from "@code-surfer/themes";

export const theme = vsDark;

# Intro

### Alec Brunelle

### Software dev @ Yolk AI

---

<h3>Everything in Javascript</h3>

<Appear>
  <h3>For Better</h3>
  <h3>... or Worse</h3>
</Appear>

<Notes>

- backend, frontend
- 

</Notes>

---

<h3>Everything in GraphQL</h3>

<Appear>
  <h3>For Better</h3>
  <h3>... and Better</h3>
</Appear>

<Notes>

- really love it
- passionate about it
- very excited and feel lucky to work on it everyday

</Notes>

---

Frontend developer for three years

Apollo Client for almost a year

---

# state management is hard

<Notes>

- many many solutions
- redux, react state/context, flux
- apollo local state is one of those solutions

</Notes>

---

insert table flip image

<Notes>

- You may have felt like this at one point when going through state management in js
- you always get this thought in the back of your mind that it should somehow be easier

</Notes>

---

# why is it needed?

<Notes>

- you hear frontend developers always talking about it

</Notes>

---

insert image of very complicated frontend

<Notes>

- complex SPA's require a user to perform many actions before talking with the API or network
    - e.g. a flow editor (it was ours in that case), a multi-page form,
- can use React State for a lot of interactions
- doesnt scale well, starts to break down when multiple components need to hold state

</Notes>

---

# hasn't this been solved already?

<Notes>

* yes
  * many solutions like redux and flux
  * if using it already and loving it, no reason to switch
  * if adopting graphql, then seriously consider switching
* no
  * going to be duplicating a lot of work if already working with graphql

</Notes>

---

# apollo local state to the rescue!

<Appear>
    <h1>Sort of...</h1>
</Appear>

<Notes>

- making many many mutations sucks super hard
- show boilerplate heavy mutation
- needed something better

</Notes>

---

# Pro

It's GraphQL

<Notes>

pro:

* All the benefits of GraphQL
  * strongly typed data model
* very easy to adopt for apollo client users
  * judging by stats, probably lots of you
- Actions are performed with mutations, something that previous GraphQL users already understand

</Notes>

---

# Pro

Apollo

<Notes>

-  almost zero extra config if already using apollo client
- Staying within the Apollo ecosystem meant smooth integration with existing tools, meaning less overhead for developers.

</Notes>

---

# Pro

Queries

<Notes>

* components only ask for the data they need
  * queries!

</Notes>

---

# Pro

A lot less code

<Notes>

* store structure shared between data fetching cache and local state cache
  * [a lot less work for you](https://blog.apollographql.com/reducing-our-redux-code-with-react-apollo-5091b9de9c2a)

</Notes>

---

# Pro

Funded ðŸ’°

<Notes>

funded project (apollo) means docs, support and plenty of eyes on the projects

</Notes>

---

# Con

Quantity of Mutations

<Notes>

- making many many mutations sucks super hard
- show boilerplate heavy mutation

</Notes>

---

# Con

Usage

<Notes>

- wont find a lot of stack over flow questions
- maybe thats because it uses so much of apollo cache already?

</Notes>


---

# Con

Boilerplate / Dev Experience

<Notes>

- could be much better
- part of the reason why I am giving this talk
- want it to get better as I had such a good experience

</Notes>

---

pattern

<Notes>

* ideally you want to make your actions one-to-one with user actions
* Easy to reason
* Makes them small

</Notes>

---

Actions are 1-1 with user interactions

---

<CodeSurfer>

```graphql title="Define client-side schema"
# clientOnly.graphql

extend type Mutation {
  # A mutation which edits the name on a Github Issue.
  editGithubIssue(input: EditGithubIssueInput!): Boolean
}

input EditGithubIssueInput {
  id: ID!
  name: String!
}
```

```jsx 7:10 title="Define the fragment"
import React from "react";

import { GithubIssuePiece } from './graphql-types'
import { UPDATE_ISSUE_NAME } from './mutations/updateIssuename';

const GITHUB_ISSUE_FRAGMENT = gql`
  fragment GithubIssuePiece on GithubIssue {
    id @client
    name @client
  }
`
```

```jsx 2,7:14 title="Use the mutation"
const IssueInput: React.FC<{ issue: GithubIssuePiece }> = ({ issue }) => {
  const updateIssuename = useMutation(UPDATE_ISSUE_NAME);
  return (
    <input
      value={issue.name}
      onChange={newInputValue => {
        updateIssuename({
          variables: {
            input: {
              id: issue.id,
              name: newInputValue
            }
          }
        });
      }}
    />
  );
};
```

</CodeSurfer>

<Notes>


</Notes>

---

Same Apollo Client logic

Components will be updated

<Notes>



</Notes>

---

Okay, but what about the mutation resolver definition?

---


<CodeSurfer>

```ts file=./mutations/updateIssueName.ts subtitle="It's pretty big"
```

```diff 11:15 subtitle="define local mutation"
```

```diff 37:41 subtitle="Get the id of the object in the cache"
```

```diff 44:48 subtitle="Get the data from the cache"
```

```diff 54:57 subtitle="Update the data"
```

```diff 60:65 subtitle="Write the data to the cache"
```

</CodeSurfer>

<Notes>

* Goes to show the dev experience here is lacking
* this is how to do it, straight from the docs
* Ts makes this worse but I havent wrote regular JS in almost two years

</Notes>

---

insert wut image

---

Problems

* Boilerplate
* Testing

<Notes>

* lots of boilerplate and testing was not easy, very terse and prone to error
  * way too much code for such small manipulations to data
* to test this you need a fake store and perform fake mutation on it
* hard to test
  * lots of use of external apis

</Notes>

---

this was not as bad in redux

why?

---

Let's take some inspiration

* reducers are pure functions
* always write data back in the same structure as you read it
* already doing small actions

---

how can we apply this

---

we are only doing 4 things here:

* Get the id
* Get the data from the cache
* Update the data locally
* Write the data back to the cache

---

<CodeSurfer>

```ts file=./common/createResolver.ts
```

</CodeSurfer>

---

<CodeSurfer>

```ts title="Lets go back to our issue mutation" file=./mutations/newUpdateIssueName.ts
```

</CodeSurfer>

---

With this new set of utility function, it covered about 90% of our use cases.

---

recap

* chose to invest heavily in apollo local state for a complicated flow editor - type app
* saw problems in apollo local state which required tweaking
* used inspiration from redux to make apollo local state experience much better
  * was really just functional principles such as
    * pure funcs
    * reducer funcs

---

[Hugh Wilson of the Apollo team has said they are looking to improve it.](https://spectrum.chat/apollo/apollo-link-state/apollo-link-state-vs-redux-vs-react-hooks-context~dcb1118c-8819-4593-8b22-040229ed4282?m=MTU1MTM3ODkzNjcxNg==)


Maybe one day I'll make a pr to get this sort of feature in who knows.

---

# If you liked this:

## https://blog.alec.coffee/apollo-local-state-pains/

---

# Follow Me:

## [@yourboybigal](https://twitter.com/yourboybigal)

## [alec@alec.coffee](mailto:alec@alec.coffee)
